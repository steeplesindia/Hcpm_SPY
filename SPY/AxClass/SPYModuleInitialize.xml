<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SPYModuleInitialize</Name>
	<SourceCode>
		<Declaration><![CDATA[
class SPYModuleInitialize
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>initializeExpressionFunction</Name>
				<Source><![CDATA[
    private void initializeExpressionFunction()
    {
        SPYExpressionEvaluationEngine       expressionEvaluationEngine = new SPYExpressionEvaluationEngine(SPYProcess::PayProcess);
        expressionEvaluationEngine.traverseFunct();
        info("@SPY1123");
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeNumberSeq</Name>
				<Source><![CDATA[
    private void initializeNumberSeq()
    {
        SPYNumberSeqModulePayroll payroll = new SPYNumberSeqModulePayroll();
        payroll.load();
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    private void run()
    {
        ttsbegin;
        try
        {
            //this.initializeExpressionFunction();
            this.clearContextCache();
            this.initializeNumberSeq();
            this.initializeSystemExpressionFunction();
            this.initializeConfigKey();
            this.initializeParameter();
            ttscommit;
        }
        catch(Exception::Error)
        {
            ttsabort;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearContextCache</Name>
				<Source><![CDATA[
    private void clearContextCache()
    {
        SPYExpressionCache::clearAllScopes();
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        SPYModuleInitialize     moduleInitialize = new SPYModuleInitialize();
        if(Box::confirm("@SPY1055") == true)
            moduleInitialize.run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeSystemExpressionFunction</Name>
				<Source><![CDATA[
    private void initializeSystemExpressionFunction()
    {
        SPYExpressionFunction       expressionFunction;
        container        systemFunctionCon = [
                ["PL_YTDAMOUNT", "Payroll Ledger YTD Amount", SPYExpressionDataType::Real,'<p>This method is used to return the year to date amount for a given pay element from the payroll ledger. The year start is picked from 1st Jan of the year of payroll processing. This method return the amount in base currency and not the transaction currency; which might be different as entered on the salary structure form. </p><p><br></p><p><strong>Parameters:</strong> </p><p>setFunctionParameter1:&nbsp;Pay element code</p><p><br></p><p><strong>Example:</strong></p><p></p><p>double&nbsp;paidBasic = 0.00;</p><p><br></p><p></p><p>[setFunctionParameter1("BASIC")];<br></p>paidBasic = [PL_YTDAMOUNT];'],
                ["BL_YTDAMOUNT", "Benefit Ledger YTD Amount", SPYExpressionDataType::Real,'<br><p>This function returns the total of a benefit type of pay element from the benefit ledger, from the start of the year to the beginning of the payroll period being evaluated. The amount along with P&L amount in the accounting currency is considered for the calculation. The amount for the current payroll period would not be included in the results. The amount is returned in the base currency of the system.</p><p><br></p><p>The year start date is calculated as starting from 1<sup>st </sup>Jan of the year assigned in the payroll context. </p><br><p><strong>Parameters:</strong><br></p><p>setFunctionParameter1: Pay element code of the benefit being evaluated.</p><br><br><p><strong>Example:</strong><strong></strong></p><strong></strong><p>double retAmount = 0.00;<br><br></p><p>[setFunctionParameter1("ATICKET")] <br></p><p>retAmount = [BL_YTDAMOUNT];</p><br><br>'],
                ["EMP_DOJ", "Employee date of Joining", SPYExpressionDataType::Date,'<br><p>This function returns the date of joining of the employee. </p><p><br></p><p><strong>Parameters: </strong></p><p>NA</p><p><br><strong>Example:</strong></p><p>DateTime&nbsp; startDate , doj;&nbsp; </p><p>double unpaidDays;</p><p><br></p><p>startDate = [PERIOD_STARTDATE]; </p><p>doj = [EMP_DOJ];&nbsp; </p><p><br></p><p>if ( doj &gt; startDate )&nbsp; </p><p>{&nbsp;&nbsp; unpaidDays = doj.Day - 1; }&nbsp; </p><p><br></p><p><br></p>'],
                ["REF_GETAMT", "Get an amount from the reference ledger", SPYExpressionDataType::Real,'<br><br><p>This function returns the total of a reference type of pay element in a given date range. The date range is set by the period start and period end of the payroll context. The amount returned is in the base currency of the system.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<br><strong>Parameters:</strong></p><p>setFunctionParameter1: Pay element code of the reference pay element being evaluated should be assigned.</p><p><br></p><p><strong>Example:</strong></p><p>double retAmount = 0.00;</p><br><p>[setFunctionParameter1("ATICKET")];<br></p><p>retAmount = [REF_GETAMT];</p><br><br>'],
                ["EMP_NATIONALITY", "Employee nationality", SPYExpressionDataType::String,'<p><br></p><p>This function return the nationality of the current employee evaluated from the payroll context. </p><p><br></p><p><strong>Parameters:</strong></p><p>N/A</p><p><br></p><p><strong>Example:</strong></p><p>[setFunctionParameter1("BASIC")]; </p><p>double basic = [EMP_ELEMENT_AMOUNT]; </p><p><br></p><p>[setFunctionParameter1("HRA")]; </p><p>double hra = [EMP_ELEMENT_AMOUNT];&nbsp; </p><p>double amount = basic+hra;</p><p><br></p><p>if ([EMP_NATIONALITY] == "SAU") </p><p>&nbsp; return 0.15*amount;&nbsp; </p><p>else </p><p>&nbsp; return 0.09*amount;</p>'],
                ["JNL_ADJAMTYTD", "Adjustment amount year to date", SPYExpressionDataType::Real,'<br><p>This function returns the total amount posted in the adjustment journal for the employee in the current year from the starting of the year until the start of the payroll period. The amounts for the current payroll period are excluded from the results. </p><p><br></p><p>The start date of the current year is calculated as the 1st of Jan of the year in which the payroll is being calculated. </p><p><br></p><p><br></p><strong><p>Parameters:<br></p></strong><p>setFunctionParameter1: Pay element code of the pay element being evaluated should be assigned.</p><p><br></p><p><strong>Example:</strong></p><p>double retAmount = 0.00;</p><br><p>[setFunctionParameter1("ATICKET")];<br></p><p>retAmount = [JNL_ADJAMTYTD];<br><br><br></p>'],
                ["JNL_ADJAMOUNT", "Adjustment amount posted in journal", SPYExpressionDataType::Real, '<br><p>This function returns the adjustment amount posted in the current period using the adjustment journals for the current payroll period. </p><p><br></p><p><strong>Parameters:</strong><br></p><p>setFunctionParameter1: Pay element code of the pay element being evaluated should be assigned.</p><p><br></p><p><strong>Example:</strong></p><p>double retAmount = 0.00;</p><br><p>[setFunctionParameter1("ATICKET")] ;<br></p><p>retAmount = [JNL_ADJAMT];</p><br><br><br><br>'],
                ["REF_GETYTDAMT", "Get the year to date amount from reference ledger", SPYExpressionDataType::Real,'<br><p>This function returns the sum of amount from the reference ledger for a given pay element. The date range used is from the beginning of the year to the payroll period start date. The values from the current payroll run are not included in the result. </p><p><br></p><p><strong>Parameters:</strong><br></p><p>setFunctionParameter1: Pay element code of the reference pay element being evaluated should be assigned.</p><p><br></p><p><strong>Example:</strong></p><p>double retAmount = 0.00;</p><br><p>[setFunctionParameter1("ATICKET")];<br></p><p>retAmount = [REF_GETYTDAMT];</p><p><br><br><br><br></p>'],
                ["MONTHLY_PARENT_AMT", "Monthly parent element amount", SPYExpressionDataType::Real,'<br><p>This function returns the monthly amount of the parent element that is attached to the pay element being processed. </p><p><br></p><p><strong>Parameters:</strong></p><p>N/A</p><p><br></p><p><strong>Example:</strong></p><p>double deductionAmt; </p><p>double unpaidDays = 0.00;&nbsp; </p><p><br></p><p>[setFunctionParameter1("Unpaid")]; </p><p>unpaidDays += [AB_EMP_APPLIED];&nbsp;&nbsp; </p><p><br></p><p>[setFunctionParameter1("Sick")]; </p><p>double slEntitled = [AB_EMP_ENTITLED]; </p><p>double slTaken = [AB_EMP_AVAILED]; </p><p>double slApplied = [AB_EMP_APPLIED];&nbsp; //SL calculation starts forward from sick leaves already taken and processed&nbsp; </p><p><br></p><p>for (double ctr = slTaken; ctr &lt;= slTaken + slApplied; ctr++ ) </p><p>{</p><p>&nbsp;&nbsp; if ( ctr &gt; ( slEntitled * 2 ) )</p><p>&nbsp;&nbsp;&nbsp;&nbsp; { unpaidDays += 1; }</p><p>&nbsp;&nbsp; else if ( ctr &gt; slEntitled )</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { unpaidDays += 0.5; } </p><p>}&nbsp;&nbsp; </p><p><br></p><p>deductionAmt = unpaidDays * ( [MONTHLY_PARENT_AMT] / 30 ) ;&nbsp; </p><p><br></p><p>return ( deductionAmt ) ;</p><br><br>'],
                ["OTHOURS", "Overtime hours of a given type", SPYExpressionDataType::Real,'<br><p>This function returns the total OT hours of a given type from the Overtime ledger in the current payroll period as set by the payroll context. </p><p><br></p><p><strong>Parameters:</strong></p><p>setFunctionParameter1: Overtime type code of the overtime being calculated.</p><p><br></p><p><strong>Example:</strong></p><p>double hours, basicSalary ;</p><p><br></p><p>[setFunctionParameter1("BASIC")];</p><p>hours = [OTHOURS] ;&nbsp; </p><p><br></p><p>[setFunctionParameter1("BASIC")];</p><p>basicSalary = [EMP_ELEMENT_AMOUNT] ;&nbsp; </p><p><br></p><p>return ( (basicSalary / ( 30 * 8 ) ) * hours * 1.25 );<br><br></p>'],
                ["AB_EMP_AVAILED", "Total Absence already taken and processed", SPYExpressionDataType::Real, '<br><p>This function returns the No of days of leaves availed in the current year by a given employee. The current year is calculated from 1<sup>st </sup>of January to the beginning of the current period. This does not return the leaves applied for in the current payroll period. </p><p><br></p><p><strong>Parameters:</strong></p><p>setFunctionParameter1: This parameter accepts the absence leave code for which the balance is being queried for. </p><p><br></p><p><strong>Example: The below function is used to validate a leave application</strong></p><p>[setFunctionParameter1("Vacation")]; </p><p>double leaveCount = [AB_LEAVEAPP_CNT]; </p><p><br></p><p>double leaveBalance = 0;&nbsp; </p><p>if ( leaveCount &gt; 2 ) </p><p>{</p><p>&nbsp;&nbsp; string s = "This leave cannot be applied more than :" + Convert.ToString( leaveCount ) + " times in a year";</p><p>&nbsp;&nbsp; #info(s, "e");&nbsp;&nbsp;</p><p>&nbsp;&nbsp; leaveBalance = 0; </p><p>} </p><p>else {</p><p>&nbsp; string s = "This leave is applied :" + Convert.ToString( leaveCount ) + " times this&nbsp; year";</p><p>&nbsp; #info(s, "i");</p><p>&nbsp;&nbsp; leaveBalance = [AB_EMP_ENTITLED] - [AB_EMP_AVAILED] ; </p><p>}&nbsp; </p><p><br></p><p>return(leaveBalance);<br><br><br></p>'],
                ["AB_LEAVEAPP_CNT", "Count of leave app with given absence code in the year", SPYExpressionDataType::Real,'<br><p>This function returns the no of times a leave application has been filed for a given absence code by a given employee in the current year. This function comes handy when a leave application has to be validated to be allowed only for a given no of times in a year. </p><p><br></p><p><strong>Parameters:</strong></p><p>setFunctionParameter1: This parameter accepts the absence leave code for which the count is being calculated for. </p><br><br><p>Example:</p><p>[setFunctionParameter1("Vacation")]; </p><p>double leaveCount = [AB_LEAVEAPP_CNT]; </p><p>double leaveBalance = 0;&nbsp; </p><p><br></p><p>if ( leaveCount &gt; 2 ) </p><p>{</p><p>&nbsp;&nbsp; string s = "This leave cannot be applied more than :" + Convert.ToString( leaveCount ) + " times in a year";</p><p>&nbsp;&nbsp; #info(s, "e");</p><p>&nbsp;&nbsp; leaveBalance = 0;</p><p>&nbsp;} else {</p><p>&nbsp; string s = "This leave is applied :" + Convert.ToString( leaveCount ) + " times this&nbsp; year";</p><p>&nbsp; #info(s, "i");</p><p>&nbsp;&nbsp; leaveBalance = [AB_EMP_ENTITLED] - [AB_EMP_AVAILED] ;</p><p>&nbsp;}&nbsp; </p><p><br></p><p>return(leaveBalance);<br></p>'],
                ["AB_EMP_ENTITLED", "Total Absence Entitled", SPYExpressionDataType::Real,'<br><p>This function returns the no of leaves that an employee is entitled for of given absence code. </p><br><p>The balance is calculated from the employee benefits, if the employee benefits are not entered then the entitlement is calculated using the absence ledger.</p><p><br><strong>Parameters:</strong><br></p><p>setFunctionParameter1: This parameter accepts the absence leave code for which the entitlement is being calculated for. </p><p><br></p><p><strong>Example:</strong></p><p>double retAmount = 0.00;</p><br><p>[setFunctionParameter1("AL")];<br></p><p>retAmount = [AB_EMP_ENTITLED];</p><p><br></p>'],
                ["AB_ACCRUE_QTY", "The quantity being accrued in the current period", SPYExpressionDataType::Real, '<div><font>This function returns the total quantity accrued for a given absence code from the absence ledger.&nbsp;</font></div><div><font><br></font></div><div><font>This function does not consider any encashment type entries passed using the benefit ledger.&nbsp;</font></div><div><font><br></font></div><div><font>The quantity is calculated for the calculation period which can be more than one for a payroll period in case of increments. <br><br><font><strong><u>Parameters:</u></strong><br><p>setFunctionParameter1: This parameter accepts the absence leave code. </p><p><br></p><p><strong>Example:</strong></p><p>[setFunctionParameter1("Vacation")]; </p><p>return ( [AB_ACCRUE_QTY] );</p><br><br></font></font></div>'],
                ["AB_EMP_APPLIED", "Total Absence days applied in current Attendance period", SPYExpressionDataType::Real,'<p>This function returns the absence qty applied for by an employee in a given period using a leave application request or using the absence journal. </p><p><br></p><strong>Parameter:</strong><br><p>setFunctionParameter1: This parameter accepts the absence leave code for which the balance is being queried for. </p><p><br></p><p>Example:</p><p>double unpaidDays = 0.00;&nbsp; </p><p><br></p><p>[setFunctionParameter1("Unpaid")]; </p><p>unpaidDays += [AB_EMP_APPLIED];&nbsp; </p><p><br></p><p>return ( unpaidDays ) ;</p><br><br>'],
                ["EMP_SERVICEDAYS", "Employee service days", SPYExpressionDataType::Real,'<p>This function returns the total no of service days of the employee since the date of joining.</p><p><br></p><p><strong>Parameters:</strong></p><p>N/A</p><p><br></p><p><strong>Example: The following formula returns service award days using 21 days per year for less than 5 years of service and 30 for above.</strong></p><p><br></p><p>double empServiceDays, daysInYear, balanceQty;&nbsp; </p><p>empServiceDays = [EMP_SERVICEDAYS]; </p><p>daysInYear = 365;</p><p><br></p><p>if ( empServiceDays &lt; daysInYear * 5)</p><p>&nbsp; return&nbsp; ((( empServiceDays *21)/ daysInYear )); </p><p>else</p><p>&nbsp; return&nbsp; (( daysInYear *3 *( 21/daysInYear ))+((( empServiceDays - ( daysInYear*5))*30)/ daysInYear ) );</p>'],
                ["EMP_ATTRIBUTE_SAL", "Employee salary based on an attribute", SPYExpressionDataType::Real,'<br><p>This function returns the total salary for an employee across all the pay element that carry a certain attribute. Attributes can be assigned to pay&nbsp; elements to distinguish them from others for specific business case requirements. </p><p><br></p><p>This function returns the net amount payable from the ledger tables. The standard amounts from the worker salary form are returned using&nbsp; the function EMP_ATTRIBUTE_PKG.</p><p><br></p><p><strong>Parameters:</strong></p><p>setFunctionParameter1: This parameter accepts the attribute for which the total amount is being calculated. </p><br><br><p><strong>Example:</strong></p><p>[setFunctionParameter1("TAX")]; </p><p>return( [EMP_ATTRIBUTE_SAL] );</p><p><br></p><p><br><br></p>'],
                ["EMP_ATTRIBUTE_YTDSAL", "Year to date salary for a given pay attribute", SPYExpressionDataType::Real,'<br><p>This function returns the total salary for an employee across all the pay element that carry a certain attribute from the beginning of the current year to the current period. The results don’t include the amounts from the current payroll period. This function comes handy during tax calculations.</p><p><br></p><p><br></p><p><strong>Parameters:</strong></p>setFunctionParameter1: This parameter accepts the attribute for which the total amount is being calculated.<p><br></p><p><strong></strong><br></p>'],
                ["EMP_ATTRIBUTE_BTDSAL", "Balance to date salary", SPYExpressionDataType::Real, '<br><p>This function returns the total salary that has been ever paid to an employee (since date of joining) with the pay elements of a certain attribute. This does not include the salary from the current payroll period. </p><p><br></p><p>This function processes the results in the base currency of the company. </p><p><br></p><p><strong>Parameters:</strong></p><p>setFunctionParameter1: This parameter accepts the attribute for which the total amount is being calculated<br></p><p><br></p>'],
                ["MONTHLY_QTY", "Monthly benefit quantity", SPYExpressionDataType::Real,'<br><p>This function returns the monthly qty from the employee benefits screen for the current employee and benefit being processed. </p><p><br></p><p><strong>Parameters:</strong></p><p>N/A</p><p><br></p><p><strong>Example:</strong></p><p>return ( [MONTHLY_QTY] );</p><br><br>'],
                ["MONTHLY_AMT", "Monthly Amount", SPYExpressionDataType::Real,'<br><p>This function returns the amount from the monthly amount field. This works for payroll as well as benefit&nbsp;type of pay elements. </p><p><br></p><p><br></p><p><strong>Parameters:</strong></p><p>N/A</p><p><br></p><p><strong>Example:</strong></p><p>return ( [MONTHLY_AMT]&nbsp; *&nbsp;&nbsp; [CALC_DAYS] / [PERIOD_CALDAYS]&nbsp; );<br></p>'],
                ["EMP_SALARY", "Employees gross salary", SPYExpressionDataType::Real, '<br><p>This function returns the total salary for an employee in the given payroll run instance.</p><p><br></p><p><strong>Parameter:</strong></p><p>N/A</p><p><br></p><p><strong>Example:</strong></p><p>[setFunctionParameter1("Vacation")]; </p><p>return( ( [EMP_SALARY] / 30.00 ) * [AB_ACCRUE_QTY] );</p><br><br>'],
                ["EOS_REASON", "Seperation Reason", SPYExpressionDataType::String,'<br><br><p>This function returns the reason for separation for a worker in a given legal entity. The reason for separation can have an impact on the way the separation calculations are performed and hence this function comes handy to address the different business scenarios around separation calculation. </p><p><br></p><p><strong>Parameters:</strong></p><p>N/A</p><p><br></p><p><br></p><p><strong></strong><strong>Example:</strong></p><p><strong></strong>string reasonCode ; </p><p>int retValue = 0;&nbsp; </p><p><br></p><p>reasonCode = [EOS_REASON];&nbsp; </p><p><br></p><p>if ( reasonCode == "Terminated" )</p><p>&nbsp; retValue = [BalancedBenefitAmount]; </p><p><br></p><p>return( retvalue );<br></p>'],
                ["CONFIG_KEY_DOUBLE", "Get the configuration key value using", SPYExpressionDataType::Real,'<p>This function returns the value of a configuration key type casted as a double value.</p><p><br></p><p>The configuration keys can be used to make certain elements of the formulas as configurable. This configuration enables the formulas to be maintained without the need of making a technical change to the formula, which requires some technical skills. </p><p><br></p><p><strong>Parameters:</strong></p>setFunctionParameter1:This parameter accepts the configuration key for which the value is required<p><br></p><p><br></p><p><strong>Example:</strong></p><p>string job = [EMP_JOB]; </p><p>double amt = 0; </p><p><br></p><p>if(job == "Manager")</p><p>&nbsp;{</p><p>&nbsp;[setFunctionParameter1("MA_Manager")];</p><p>&nbsp; amt = <strong>[CONFIG_KEY_DOUBLE]</strong>; </p><p>} </p><p>else if(job == "Consultant")</p><p>{</p><p>&nbsp;[setFunctionParameter1("MA_Consultant")];</p><p>&nbsp;amt = <strong>[CONFIG_KEY_DOUBLE];</strong> </p><p>} </p><p>else if(job == "HR Director") </p><p>{</p><p>&nbsp;[setFunctionParameter1("MA_HRD")];</p><p>&nbsp;amt = <strong>[CONFIG_KEY_DOUBLE];</strong></p><p>&nbsp;}&nbsp; </p><p><br></p><p>return amt;</p>'],
                ["CALC_DAYS", "Days for payroll calculation", SPYExpressionDataType::Real, "<br><p>This function returns the no of days the payroll is being calculated for; this is different from period days </p><p><br></p><p>i.e. when there is a mid-month change in salary the period days does not change, however the calcdays would change.&nbsp;&nbsp;&nbsp; </p><p><br></p><p><br></p><br><br>"],
                ["PERIOD_WORKDAYS", "Working days in a period", SPYExpressionDataType::Real, "This function returns the no of working days in the period being evaluated for the current employees based on the calendar that is attached to him. The date range is selected using the attendance period. This function is used for the employees who are working based on a single calendar applicable for each date.<div><br>This function is generally used in combination with the EMP_ISCALENDAR&nbsp;function, which checks if the employee is calendar based or roster based.&nbsp;<div><br><strong>Parameters:&nbsp;</strong>N/A</div></div>"],
                ["NO_OF_DEPENDENTS", "Dependent kids between 3 and 20 on payroll start date", SPYExpressionDataType::Real,'<br><p>This function returns the no of dependents for an employee. If the dependents need to be between a certain age range then the same should be set in configuration key, generally kids are considered dependent only within a certain age bracket.</p><br><p>As the function can be used to calculate the dependents with different relations, The configuration key values should be of the format: </p><ul><li>&lt;relationshipType&gt;+&lt;fromAge&gt;&nbsp;&nbsp;&nbsp;&nbsp;</li><li>&lt;relationshipType&gt;+&lt;toAge&gt;<br><br></li></ul><p><strong>Parameters:</strong></p><p>setFunctionParameter1: This parameter accepts the relationship type that needs to be evaluated. The function can hence return the dependent Child, Spouse etc. </p><br><br>'],
                ["EMP_MARITAL_STATUS", "Marital status of the employee", SPYExpressionDataType::String,'<br><p>This function returns the marital status of the employee. The function comes handy in cases where some of the tax components and rebates are applicable based on the marital status. </p><p><br></p><p><strong>Parameters:</strong></p><p>N/A</p><br><br>'],
                ["EMP_AGE", "Age of the employee", SPYExpressionDataType::Real,'This function returns the age of the employee in years on the transaction date. The function returns the age in decimal and can be used to <p>evaluate conditions based on age.</p><p><br></p><p><strong>Parameters:</strong></p><p>N/A</p><p><br></p><p><strong>Example:</strong></p><p>double totSalary; </p><p>double retValue;&nbsp; </p><p>totSalary =[EMP_CURNSSFSAL] ;&nbsp; </p><p><br></p><p>if([EMP_AGE]&lt;=64) </p><p>{ retValue = totSalary * 0.085 ; } </p><p>else&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;retValue=0;&nbsp; </p><p><br></p><p>return ( retValue );</p>'],
                ["LOAN_DEDUCTION", "Loan amount deductions", SPYExpressionDataType::Real,'<p>This function returns the total recovery amount against a given loan type code using the pay loan ledger.</p><p><br></p><p><strong>Parameters:</strong></p><p>setFunctionParameter1: This parameter accepts the code of the loan for which the amount is being calculated</p><p><br></p><p><strong>Example:</strong></p><p>[setFunctionParameter1("Personal Loan")]; </p><p>return [LOAN_DEDUCTION];</p>'],
                ["LOAN_DISBURSEMENT", "Loan amounts to be disbursed in a given period", SPYExpressionDataType::Real,'<br><p>This function returns the total amount to be disbursed to the employee against a given loan type in the current payroll processing month. </p><p><br></p><p><br></p><p><strong>Parameters:</strong><br></p><p>setFunctionParameter1: This parameter accepts the code of the loan for which the amount is being calculated.</p><p><br></p><p><strong>Example:</strong></p><p>[setFunctionParameter1("Personal Loan")];&nbsp; </p><p>return ( <strong>[LOAN_DISBURSEMENT]</strong> );</p><br><br><p><br></p>'],
                ["PERIOD_CALDAYS", "Calendar days in a period", SPYExpressionDataType::Real, "<p>This function returns the no of calendar days in the payroll period being processed.</p><p><br></p><p>The calendar configured on the employee is considered for the calculation. <br></p><p><br></p><p><b>Parameters:&nbsp;</b></p><p>N/A</p>"],
                ["BL_GETAMT", "Net amount for a given benefit in the current month from the benefit ledger", SPYExpressionDataType::Real,'<p>This function returns the total of a benefit type of pay element from the benefit ledger, for the payroll period being evaluated.The amount along with P&L amount in the accounting currency is considered for the calculation</p><p><br></p><p><strong>Parameters:</strong></p><p>setFunctionParameter1: Pay element code of the benefit being evaluated</p><p><br></p><p><strong>Example:</strong></p><p>double paidATicket = 0.00;</p><br><p>[setFunctionParameter1("ATICKET")];</p><p>paidATicket&nbsp; = [BL_GETAMT];</p><p><br></p><p><br></p>'],
                ["PL_GETAMT", "Net amount for a given payroll element in the current month from the payroll ledger", SPYExpressionDataType::Real,"<br><p>This function returns the amount from the payroll ledger for the current payroll period and a given pay element. </p><p><br></p><p><strong>Parameter: </strong><br></p><p>setFunctionParameter1:&nbsp;Pay element code </p><br><br><br><br><br><br>"],
                ["EMP_CURYEARMNTHS", "Gives the no of months worked in the current payroll year", SPYExpressionDataType::Real,'<br><p>This function returns the total no of months that the current employee has worked in the current legal entity and payroll year. </p><p><br></p><p><strong>Parameters:</strong></p><p>N/A</p><p><br></p><p><strong>Example:</strong></p><p>double totSalary; </p><p>double dblMonths, amtCeiling; </p><p>double retValue;&nbsp; </p><p><br></p><p>dblMonths = [EMP_CURYEARMNTHS] ; </p><p>amtCeiling = dblMonths&nbsp; * 2500000.00 ;&nbsp;</p><p><br></p><p>totSalary = [EMP_PREVNSSFSAL] + [EMP_CURNSSFSAL] ;&nbsp; </p><p><br></p><p>if (&nbsp; totSalary &lt;= amtCeiling&nbsp; )</p><p>&nbsp;&nbsp;&nbsp;&nbsp; retValue = totSalary * 0.08 ; </p><p>else</p><p>&nbsp; {&nbsp;&nbsp; retValue = amtCeiling * 0.08; }&nbsp;&nbsp;</p><p><br></p><p>return ( retValue );</p><br><br>'],
                ["AB_UNPAID_DAYS", "Total no of unpaid type of leaves in the current timesheet period", SPYExpressionDataType::Real,'<p><br></p><p>This function returns all the unpaid days during the current timesheet period. The function does not accept any parameter and picks all the leave codes that are marked as Unpaid in the absence code master form. </p><p><br></p><p><strong>Parameters:</strong></p><p>N/A</p>'],
                ["AB_LEAVE_DAYS", "Total no of leave days in the current timesheet period", SPYExpressionDataType::Real,'<p>This function returns all the leave days for an employee during a timesheet period for a given Absence code.&nbsp;</p><p><br></p><p><br></p><p>For requirements like transport allowance which, is only paid for the days when an employee is not on leave (the leave could be of any type), This function call also be used with a blank parameter for the Abensce code in which case it would return the leave days across all the different absence codes.&nbsp;</p><p><br></p><p><strong>Parameters:</strong></p><p></p>[setFunctionParameter1("Vacation")];<br><br><br>'],
                ["LOAN_CNT", "Count of no of times a loan has been applied in the current year", SPYExpressionDataType::Real,'<br><p>This function returns the total no of time a loan application of a given loan type has been applied in the system, in the current financial year. The amount in returned in the local currency of the company. </p><p><br></p><p><strong>Parameters:</strong><br></p><p>setFunctionParameter1: This parameter accepts the code of the loan for which the count is being calculated.</p><p><br><strong>Example:</strong></p><p>double loanApplied = 0; </p><p>double retValue = 0;&nbsp; </p><p><br></p><p>[setFunctionParameter1("SALADV")]; </p><p>loanApplied = <strong>[LOAN_CNT];</strong>&nbsp; </p><p><br></p><p>if ( loanApplied != 0 ) </p><p>{</p><p>&nbsp;string s = "This loan has already been applied " + Convert.ToString(loanApplied ) + " times this year";</p><p>&nbsp;#info(s, "i");</p><p>&nbsp;retValue = 0;</p><p>&nbsp;}</p><p>else</p><p>&nbsp;{</p><p>&nbsp;&nbsp; [setFunctionParameter1("LOAN_SAL")];&nbsp;&nbsp; </p><p>&nbsp;&nbsp; retValue = [EMP_ATTRIBUTE_PKG] * 2 ;</p><p>&nbsp;}&nbsp; </p><p><br></p><p>return ( retValue );<br></p>'],
                ["LOAN_CNT_PERIODS", "Count of no of times a loan has been applied in the past given no of periods", SPYExpressionDataType::Real,'<br><p>This function returns the no of time a given loan type has been applied for the current employee in the past given no of periods.</p><br><p>This function would come handy to enforce validations on the loan application in cases where the loan cannot be applied more than a certain no of times in the past x periods. </p><p><br></p><p><strong>Parameters:</strong><br></p><p>setFunctionParameter1: This parameter accepts the code of the loan for which the count is being calculated.<br></p><p>setFunctionParameter2:This parameter accepts the no of months for which the loan should be checked for.<br><br></p><p><br><strong>Example:</strong></p><p>double loanApplied = 0; </p><p>double retValue = 0;&nbsp; </p><p><br></p><p>[setFunctionParameter1("SALADV")]; </p><p><br></p><p>loanApplied = <strong>[LOAN_CNT_PERIODS];</strong>&nbsp; </p><p><br></p><p>if ( loanApplied != 0 ) </p><p>{</p><p>&nbsp;string s = "This loan has already been applied " + Convert.ToString(loanApplied ) + " times in the last 10 months";</p><p>&nbsp;#info(s, "i");</p><p>&nbsp;retValue = 0;</p><p>&nbsp;}</p><p>else</p><p>&nbsp;{</p><p>&nbsp;&nbsp; [setFunctionParameter1("LOAN_SAL")];&nbsp;&nbsp; </p><p>&nbsp;&nbsp; retValue = [EMP_ATTRIBUTE_PKG] * 2 ;</p><p>&nbsp;}&nbsp; </p><p><br></p><p>return ( retValue );<br></p>'],
                ["LOAN_CASH_SETTLEMENT", "Loan amount cash settled in the current payroll period", SPYExpressionDataType::Real,'<br><p>This function is used to return the total amount that has been cash settled against a given loan type for an employee in the current payroll period.&nbsp; </p><p><br></p><p>This function is required in cases when a finance entry is to be generated by the payroll engine, for all the cash collected in advance towards the settlement of a loan. </p><p><br></p><p><strong>Parameters:</strong></p><p>setFunctionParameter1: This parameter accepts the code of the loan for which the amount is being calculated.</p><br><br><p><br></p><p><br></p><br><br>'],
                ["EMP_DOT", "Date of termination of the current employee", SPYExpressionDataType::Date,'<p>This function would return the termination date of the employee being currently processed.</p><p><br></p><p><strong>Parameters: </strong></p><p>N/A</p><br><br>'],
                ["CTX_PERIODFROMDATE","PeriodFromDate from the payroll context", SPYExpressionDataType::Date, '<br><p>This function is from the series of the context variables. The context functions are prefixed with CTX and can be used to fetch the value of the runtime in to the formulas. </p><p><br></p><p>This function will return the value of parameter PeriodFromDate from the context of the payroll run.</p><p><br></p><p><strong>Parameters:</strong></p><p>N/A</p><p><br><strong>Example:</strong></p><p>[setFunctionParameter1("Basic")]; </p><p>DateTime startDate = [EMP_PAYELEMENTSTARTDATE]; </p><p>DateTime endDate =<strong> [CTX_PERIODFROMDATE];</strong> </p><p><br></p><p>[setFunctionParameter1("Basic")]; </p><p>[setFunctionParameter2()]; </p><p>[setFunctionParameter3(endDate.Day)]; </p><p><br></p><p>double amt = [EMP_ATTRIBUTE_SAL_DATERANGE]; </p><p>return ( [MONTHLY_AMT] / 30 * (30 - [CALCSTARTDAY] +1 ) ) ;<br></p>'],
                ["CTX_PERIODTODATE","PeriodToDate from the payroll context", SPYExpressionDataType::Date,'<p>This function is from the series of the context variables. The context functions are prefixed with CTX and can be used to fetch the value of the runtime in to the formulas. </p><p><br></p><p>This function will return the value of parameter PeriodToDate from the context of the payroll run.</p><p><strong><br></strong></p><p><strong>Parameters:</strong></p><p>N/A</p>'],
                ["CTX_TIMESHEETFROMDATE","TimesheetFromDate from the payroll context", SPYExpressionDataType::Date, '<p>This function is from the series of the context variables. The context functions are prefixed with CTX and can be used to fetch the value of the runtime in to the formulas. </p><p><br></p><p>This function will return the value of parameter TimesheetFromDate from the context of the payroll run.</p><p><br></p><p><strong>Parameters:</strong></p><p>N/A</p>'],
                ["CTX_TIMESHEETTODATE","TimesheetToDate from the payroll context", SPYExpressionDataType::Date, '<p>This function is from the series of the context variables. The context functions are prefixed with CTX and can be used to fetch the value of the runtime in to the formulas. </p><p><br></p><p>This function will return the value of parameter TimesheetToDate from the context of the payroll run.</p><p><strong><br></strong></p><p><strong>Parameters:</strong></p><p>N/A</p>'],
                ["CTX_TRANSDATE","TransDate from the payroll context", SPYExpressionDataType::Date,'<p>This function is from the series of the context variables. The context functions are prefixed with CTX and can be used to fetch the value of the runtime in to the formulas. </p><p><br></p><p>This function will return the value of parameter TransDate from the context of the payroll run.</p><p><strong><br></strong></p><p><strong>Parameters:</strong></p><p>N/A</p>'],
                ["CTX_WORKERCALENDARID","CalendarId from the payroll context", SPYExpressionDataType::String,'<p>This function is from the series of the context variables. The context functions are prefixed with CTX and can be used to fetch the value of the runtime in to the formulas. </p><p><br></p><p>This function will return the value of parameter WorkerCalendarId from the context of the payroll run.</p><p><strong><br></strong></p><p><strong>Parameters:</strong></p><p>N/A</p>'],
                ["CTX_LEAVESETTLEMENT","LeaveSettlement from the payroll context", SPYExpressionDataType::Boolean, '<p>This function is from the series of the context variables. The context functions are prefixed with CTX and can be used to fetch the value of the runtime in to the formulas. </p><p><br></p><p>This function will return the value of parameter LeaveSettlement from the context of the payroll run. </p><p><br></p><p><strong>Parameters:</strong></p><p>N/A</p>'],
                ["CTX_PAYARREAR","PayArrear from the payroll context", SPYExpressionDataType::Boolean, '<p>This function is from the series of the context variables. The context functions are prefixed with CTX and can be used to fetch the value of the runtime parameters&nbsp;in to the formulas. </p><p><br></p><p>This function will return the value of parameter "Arrear" from the context of the payroll run. </p><p><strong><br></strong></p><p><strong>Parameters:</strong></p><p>N/A</p>'],
                ["CTX_ENDOFSETTLEMENT","EndOfSettlement from the payroll context", SPYExpressionDataType::Boolean,'<p>This function is from the series of the context variables. The context functions are prefixed with CTX and can be used to fetch the value of the runtime parameters&nbsp;in to the formulas. </p><p><br></p><p>This function will return the value of parameter "EOSRun" from the context of the payroll run. </p><p><strong><br></strong></p><p><strong>Parameters:</strong></p><p>N/A</p>'],
                ["CTX_CALCFROMDATE","CalcFromDate from the payroll context", SPYExpressionDataType::Date,'<p>This function is from the series of the context variables. The context functions are prefixed with CTX and can be used to fetch the value of the runtime parameters&nbsp;in to the formulas. </p><p><br></p><p>This function will return the value of parameter "CALCFROMDATE" from the context of the payroll run. </p><p><strong><br></strong></p><p><strong>Parameters:</strong></p><p>N/A</p>'],
                ["CTX_CALCTODATE","CalcToDate from the payroll context", SPYExpressionDataType::Date,'<p>This function is from the series of the context variables. The context functions are prefixed with CTX and can be used to fetch the value of the runtime parameters&nbsp;in to the formulas. </p><p><br></p><p>This function will return the value of parameter "CALCTODATE" from the context of the payroll run. </p><p><strong><br></strong></p><p><strong>Parameters:</strong></p><p>N/A</p>'],
                ["EMP_ATTRIBUTE_PKG", "Employee salary monthly package for a given attribute", SPYExpressionDataType::Real, '<br><p>The function stands for employee attribute package. </p><p><br></p><p>It returns the sum of Monthly amount from all the pay elements. All the salary package against a given pay element attribute are considered for the sake of calculation. Function looks at the monthly amounts in the worker position payroll and worker position benefit tables. </p><p><br></p><p>*Attributes, are user defined values that can be attached to pay elements. These attributes can then be used to construct the different business scenarios. </p><p><br></p><p><strong>Parameters:</strong></p><p>setFunctionParameter1: This parameter accepts the attribute for which the total amount is being calculated. </p><br><br><p><strong>Example: The below formula calculates the loan eligibility, considering elements marked with "LOAN_SAL" attribute</strong></p><p>double loanApplied = 0; </p><p>double retValue = 0;&nbsp; </p><p><br></p><p>[setFunctionParameter1("SALADV")]; </p><p>[setFunctionParameter2("10")]; </p><p><br></p><p>loanApplied = [LOAN_CNT_PERIODS];&nbsp;</p><p>&nbsp;if ( loanApplied != 0 ) </p><p>{</p><p>&nbsp;string s = "This loan has already been applied " + Convert.ToString(loanApplied ) + " times in the last 10 months";</p><p>&nbsp;#info(s, "i");</p><p>&nbsp;retValue = 0;</p><p>&nbsp;} </p><p>else {</p><p>&nbsp;&nbsp; [setFunctionParameter1("LOAN_SAL")];</p><p>&nbsp;&nbsp; retValue = [EMP_ATTRIBUTE_PKG] * 2 ;</p><p>&nbsp;}&nbsp;</p><p><br></p><p>return ( retValue );</p><p><br></p><p><br><br></p>'],
                ["EMP_JOB", "JobID of the current employee", SPYExpressionDataType::String,'<br><p>This function is used to return the job code of the employee being processed. The job is evaluated for the period that the payroll is being processed for. </p><p><br></p><p><strong>Parameters:</strong></p><p>N/A</p><p><br></p><p>Example:</p><p>string job = [EMP_JOB]; </p><p>double amt = 0; </p><p><br></p><p>if(job == "Manager") </p><p>{</p><p>&nbsp;[setFunctionParameter1("MA_Manager")];</p><p>&nbsp;amt = [CONFIG_KEY_DOUBLE];</p><p>&nbsp;}</p><p>&nbsp;else if(job == "Consultant") </p><p>{ </p><p>&nbsp; [setFunctionParameter1("MA_Consultant")]; </p><p>&nbsp; amt = [CONFIG_KEY_DOUBLE]; } </p><p>else if(job == "HR Director") </p><p>{ </p><p>&nbsp; [setFunctionParameter1("MA_HRD")]; </p><p>&nbsp; amt = [CONFIG_KEY_DOUBLE]; </p><p>}&nbsp; </p><p><br></p><p>return amt;</p><br><br><br><br>'],
                ["EMP_PAYELEMENTSTARTDATE", "Valid from date from worker payroll or worker benefit", SPYExpressionDataType::Date,'This function returns the "Valid from" date of the current pay element being processed. The function works for both payroll and benefit type of pay elements and reads the data from the employee salary structure.&nbsp;&nbsp;<div><br></div><div><b>Parameters:</b></div><div>N/A</div>'],
                ["EMP_ATTRIBUTE_SAL_DATERANGE", "Calculate the salary for an employee for a date range based on a pay element attribute", SPYExpressionDataType::Real,'<p>This function returns the total salary for an employee within a given date range, and across all the pay element with a certain pay element attribute. Attributes can be assigned to pay&nbsp;elements to distinguish them from others for specific business case requirements. </p><p><br></p><p>This function returns the net amount payable from the ledger tables in the local currency of the company.</p><p><br></p><p><br></p><p><strong>Parameters:</strong></p><p>setFunctionParameter1: This parameter accepts the attribute for which the total amount is being calculated. </p><p>setFunctionParameter2: This parameter accepts the StartDate for the date range to be considered.</p><p>expressionFunctionParameter3: This parameter accepts the EnDate for the date range to be considered.<br><br></p><p><strong>Example:</strong></p><p>[setFunctionParameter1("Basic")];<br></p><p>DateTime endDate = [CTX_PERIODFROMDATE];</p><br><p>[setFunctionParameter1("Basic")];<br></p><p>[setFunctionParameter2()];<br></p><p>[setFunctionParameter3(endDate.Day)];<br></p><p>double amt = <strong>[EMP_ATTRIBUTE_SAL_DATERANGE];<br><br></strong></p><p>return ( [MONTHLY_AMT] / 30 *(30 - [CALCSTARTDAY] +1 ));</p>'],
                ["PERIOD_WORKDAYS_WORKPROFILE", "No of working days in work profile", SPYExpressionDataType::Integer, "This function returns the no of working days in the period being evaluated for the current employees based on the work time profile that is attached to him. The date range is selected using the attendance period. This function is used for the employees who are working based on rosters and shifts and don't have a single calendar applicable for each date.<div><br></div><div>This function is generally used in combination with the EMP_ISCALENDAR&nbsp;function, which checks if the employee is calendar based or roster based.&nbsp;<br><br></div><div><b>Parameters:&nbsp;</b></div><div>N/A</div><div><br></div><div><br></div>"],
                ["EMP_ISCALENDAR", "If employee has calendar assigned for planned working hours", SPYExpressionDataType::Boolean,'The expected no of hours per day for an employee are configured using either a single calendar or using a roster. In case of a roster the employee has an option to be connected to different calendars on different dates.&nbsp;<div><br></div><div>This function helps to check if the employee expected hours should be picked using the roster or the calendar. The related functions to this are:&nbsp;&nbsp;<div><ul><li>[PERIOD_WORKDAYS_WORKPROFILE]</li><li>[PERIOD_WORKDAYS]</li></ul></div><div><br></div><div><b>Parameters:</b></div><div>N/A&nbsp;&nbsp;</div></div>'],
                ["PL_GETAMT_TRANSCUR", "Net amount for a given payroll element in the current month from the payroll ledger in ledger transaction currency", SPYExpressionDataType::Real],
                ["PL_YTDAMOUNT_TRANSCUR", "Payroll Ledger YTD Amount in ledger transaction currency", SPYExpressionDataType::Real, '<p>This method is used to return the year to date amount for a given pay element from the payroll ledger. The year start is picked from 1st Jan of the year of payroll processing. This method return the amount in base currency and not the transaction currency; which might be different as entered on the salary structure form. </p><p><strong><br></strong></p><p><strong>Parameters:</strong> </p><p>setFunctionParameter1:&nbsp;Pay element code</p><p><strong><br></strong></p><p><strong>Example:</strong></p><p>double&nbsp;paidBasic = 0.00;</p><p>[setFunctionParameter1("BASIC")];</p>paidBasic = [PL_YTDAMOUNT_TRANSCUR];'],
                ["BL_GETAMT_TRANSCUR", "Net amount for a given benefit in the current month from the benefit ledger in ledger transaction currency", SPYExpressionDataType::Real,'<p>This function returns the total of a benefit type of pay element from the benefit ledger, for the payroll period being evaluated. The amount along with P&L amount in the transaction currency is considered for the calculation. The currency used is the transaction currency as defined in the employee salary structure form.</p><p><strong><br></strong></p><p><strong>Parameters:</strong></p><p>setFunctionParameter1: Pay element code of the benefit being evaluated</p><p><strong><br></strong></p><p><strong>Example:</strong></p><p>double paidATicket = 0.00;</p><br><p>[setFunctionParameter1("ATICKET")];</p><p>paidATicket&nbsp; = [BL_GETAMT_TRANSCUR];</p>'],
                ["BL_YTDAMOUNT_TRANSCUR", "Benefit Ledger YTD Amount in ledger transaction currency", SPYExpressionDataType::Real,'<br><p>This function returns the total of a benefit type of pay element from the benefit ledger, from the start of the year to the beginning of the payroll period being evaluated. The amount along with P&L amount in the transaction currency is considered for the calculation. The amount for the current payroll period would not be included in the results. The amount is returned in the transaction currency as entered on the salary structure form of the employee</p><p><br></p><p>The year start date is calculated as starting from 1<sup>st </sup>Jan of the year assigned in the payroll context. </p><br><p><strong>Parameters:</strong><br></p><p>setFunctionParameter1: Pay element code of the benefit being evaluated.</p><br><br><p><strong>Example:</strong><strong></strong></p><strong></strong><p>double retAmount = 0.00;<br><br></p><p>[setFunctionParameter1("ATICKET")] <br></p><p>retAmount = [BL_YTDAMOUNT_TRANSCUR];</p><br><br>'],
                ["REF_GETAMT_TRANSCUR", "Get an amount from the reference ledger in ledger transaction currency", SPYExpressionDataType::Real, '<br><br><p>This function returns the total of a reference type of pay element in a given date range. The date range is set by the period start and period end of the payroll context. The amount returned is in the base currency of the system.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<br><strong>Parameters:</strong></p><p>setFunctionParameter1: Pay element code of the reference pay element being evaluated should be assigned.</p><p><br></p><p><strong>Example:</strong></p><p>double retAmount = 0.00;</p><br><p>[setFunctionParameter1("ATICKET")];<br></p><p>retAmount = [REF_GETAMT_TRANSCUR];</p><br><br>'],
                ["REF_GETYTDAMT_TRANSCUR", "Get the year to date amount from reference ledger in ledger transaction currency", SPYExpressionDataType::Real,'<br><p>This function returns the sum of amount from the reference ledger for a given pay element. The date range used is from the beginning of the year to the payroll period start date. The values from the current payroll run are not included in the result. </p><p><br></p><p><strong>Parameters:</strong><br></p><p>setFunctionParameter1: Pay element code of the reference pay element being evaluated should be assigned.</p><p><br></p><p><strong>Example:</strong></p><p>double retAmount = 0.00;</p><br><p>[setFunctionParameter1("ATICKET")];<br></p><p>retAmount = [REF_GETYTDAMT_TRANSCUR];</p><p><br><br><br><br></p>'],
                ["EMP_ATTRIBUTE_SAL_TRANSCUR", "Employee salary based on an attribute in ledger transaction currency", SPYExpressionDataType::Real,'<br><p>This function returns the total salary for an employee across all the pay element that carry a certain attribute. Attributes can be assigned to pay&nbsp; elements to distinguish them from others for specific business case requirements. </p><p><br></p><p>This function returns the net amount payable from the ledger tables. The standard amounts from the worker salary form are returned using&nbsp; the function EMP_ATTRIBUTE_PKG.</p><p><br></p><p>This function is similar to the EMP_ATTRIBUTE_SAL function, except that this returns the amount in the transaction currency instead of the local currency of the company. </p><p><br></p><p><strong>Parameters:</strong></p><p>setFunctionParameter1: This parameter accepts the attribute for which the total amount is being calculated. </p><br><br><p><strong>Example:</strong></p><p>[setFunctionParameter1("TAX")]; </p><p>return( [EMP_ATTRIBUTE_SAL_TRANSCUR] );</p><p><br></p><p><br><br></p>'],
                ["EMP_ATTRIBUTE_YTDSAL_TRANSCUR", "Year to date salary for a given pay attribute in ledger transaction currency", SPYExpressionDataType::Real,'<br><p>This function returns the total salary for an employee across all the pay element that carry a certain attribute from the beginning of the current year to the current period. The results don’t include the amounts from the current payroll period. This function comes handy during tax calculations.</p><p><br></p><p>This function returns the amount in the transaction currency rather than the base currency of the company. <br></p><p><br></p><p><strong>Parameters:</strong></p>setFunctionParameter1: This parameter accepts the attribute for which the total amount is being calculated.<p><br></p><p><strong></strong><br></p>'],
                ["EMP_ATTRIBUTE_BTDSAL_TRANSCUR", "Balance to date salary in ledger transaction currency", SPYExpressionDataType::Real, '<br><p>This function returns the total salary that has been ever paid to an employee (since date of joining) with the pay elements of a certain attribute. Both payroll and benefit ledgers are considered for the calculation. This function however, does not include the salary for the current payroll period.&nbsp;<br></p><p><br></p><p>This function processes the results in the transaction currency instead of the base currency of the company. </p><p><br></p><p><strong>Parameters:</strong></p><p>setFunctionParameter1: This parameter accepts the attribute for which the total amount is being calculated<br></p><p><br></p>'],
                ["LOAN_DEDUCTION_TRANSCUR", "Loan amount deductions in ledger transaction currency", SPYExpressionDataType::Real,'<p>This function returns the total recovery amount against a given loan type code using the pay loan ledger. This function is similar to LOAN_DEDUCTION except that this returns the amount in the transaction currency. </p><p><br></p><p><strong>Parameters:</strong></p><p>setFunctionParameter1: This parameter accepts the code of the loan for which the amount is being calculated</p><p><br></p><p><strong>Example:</strong></p><p>[setFunctionParameter1("Personal Loan")]; </p><p>return [LOAN_DEDUCTION];</p>'],
                ["LOAN_DISBURSEMENT_TRANSCUR", "Loan amounts to be disbursed in a given period in ledger transaction currency", SPYExpressionDataType::Real, '<br><p>This function returns the total amount to be disbursed to the employee against a given loan type in the current payroll processing month. This function is similar to LOAN_DISBURSEMENT except for it return the amount in the transaction currency instead of the local currency of the company. </p><p></p><p><br></p><p><br></p><p><strong>Parameters:</strong><br></p><p>setFunctionParameter1: This parameter accepts the code of the loan for which the amount is being calculated.</p><p><br></p><p><strong>Example:</strong></p><p>[setFunctionParameter1("Personal Loan")];&nbsp; </p><p>return ( <strong>[LOAN_DISBURSEMENT]</strong> );</p><br><br><p><br></p>'],
                ["LOAN_CASH_SETTLEMENT_TRANSCUR", "Loan amount cash settled in the current payroll period in ledger transaction currency", SPYExpressionDataType::Real,'<br><p>This function is used to return the total amount that has been cash settled against a given loan type for an employee in the current payroll period.&nbsp; </p><p><br></p><p>This function is required in cases when a finance entry is to be generated by the payroll engine, for all the cash collected in advance towards the settlement of a loan. </p><p><br></p><p>This function is similar to the LOAN_CASH_SETTLEMENT except that it return the amount in the transaction currency instead of the local currency of the company. </p><p><br></p><p><br></p><p><strong>Parameters:</strong></p><p>setFunctionParameter1: This parameter accepts the code of the loan for which the amount is being calculated.</p><br><br><p><br></p><p><br></p><br><br>'],
                ["EMP_ATTRIBUTE_SAL_DATERANGE_TRANSCUR", "Calculate the salary for an employee for a date range based on a pay element attribute in ledger transaction currency", SPYExpressionDataType::Real, '<p>This function returns the total salary for an employee within a given date range, and across all the pay element with a certain pay element attribute. Attributes can be assigned to pay&nbsp;elements to distinguish them from others for specific business case requirements. </p><p><br></p><p>This function returns the net amount payable from the ledger tables in the transaction currency of the company.</p><p><br></p><p><strong>Parameters:</strong></p><p>setFunctionParameter1: This parameter accepts the attribute for which the total amount is being calculated. </p><p>setFunctionParameter2: This parameter accepts the StartDate for the date range to be considered.</p><p>expressionFunctionParameter3: This parameter accepts the EnDate for the date range to be considered.</p><br><br><p><strong>Example:</strong></p><p>[setFunctionParameter1("Basic")];</p><p>DateTime endDate = [CTX_PERIODFROMDATE];</p><br><p>[setFunctionParameter1("Basic")];</p><p>[setFunctionParameter2()];</p><p>[setFunctionParameter3(endDate.Day)];</p><p>double amt = <strong>[EMP_ATTRIBUTE_SAL_DATERANGE];<br><br></strong></p><p>return ( [MONTHLY_AMT] / 30 *(30 - [CALCSTARTDAY] +1 ));</p>']
                , ["BL_BALAMOUNT_TRANSCUR","Benefit Ledger balance Amount in ledger transaction currency", SPYExpressionDataType::Real,'This function returns the net balance of a benefit type of pay element from the benefit ledger, excluding the accruals of the current period. The amount along with P&amp;L amount in the transaction currency is considered for the calculation.&nbsp;<br><br><p><strong>Parameters:</strong><br></p><p>setFunctionParameter1: Pay element code of the benefit being evaluated.</p><br><br><p><strong>Example:</strong><strong></strong></p><strong></strong><p>double retAmount = 0.00;<br><br></p><p>[setFunctionParameter1("ATICKET")] <br></p><p>retAmount = [BL_BALAMOUNT_TRANSCUR];</p><br><br>']
                , ["BL_BALAMOUNT","Benefit Ledger balance Amount in accounting currency", SPYExpressionDataType::Real,'<br><p>This function returns the net balance of a benefit type of pay element from the benefit ledger, excluding the accruals of the current period. The amount along with P&amp;L amount in the accounting currency is considered for the calculation.&nbsp;</p><p><br></p><br><p><strong>Parameters:</strong><br></p><p>setFunctionParameter1: Pay element code of the benefit being evaluated.</p><br><br><p><strong>Example:</strong><strong></strong></p><strong></strong><p>double retAmount = 0.00;<br><br></p><p>[setFunctionParameter1("ATICKET")] <br></p><p>retAmount = [BL_BALAMOUNT];</p>']
                , ["BL_BALQTY","Benefit Ledger balance Qty till date", SPYExpressionDataType::Real,'<p>This function returns the total balance quantity of a benefit type of pay element from the benefit ledger. The quantity accrual for the current payroll period is not included in the results.</p><p><br></p><p><strong>Parameters:</strong><br></p><p>setFunctionParameter1: Pay element code of the benefit being evaluated.</p><br><br><p><strong>Example:</strong><strong></strong></p><strong></strong><p>double retAmount = 0.00;<br><br></p><p>[setFunctionParameter1("ATICKET")] <br></p><p>retAmount = [BL_BALQTY];</p><br><br>']
                , ["EMP_AMT", 'Payroll/ Benefit amount for payelement being processed.',SPYExpressionDataType::Real,'<p>This function returns the desired amount for the pay element being processed. This function works for payroll as well as benefit&nbsp;type of pay elements. The currency for the amount returned is the same as entered on the salary structure of the employee.&nbsp;</p><p><br></p><p><strong>Parameters:</strong></p><p></p><p>setFunctionParameter1: This parameter accepts a code for the amount to be returned. The possible values for this parameter are :&nbsp;</p><p></p><ul><li>Annual<br></li><li>SemiAnnual</li><li>Quarterly</li><li>Monthly</li><li>Weekly</li><li>BiWeekly</li><li>Daily</li><li>Hourly</li></ul>&nbsp;<br><p></p><p></p><p><strong><br></strong></p><p><strong>Example:</strong></p><p>[setFunctionParameter1("Annual")];<br></p><p>return ( [EMP_AMT]&nbsp; / 365.00 );</p>']
                , ["EMP_QTY", 'Benefti qty for benefit being processed.', SPYExpressionDataType::Real,'<p>This function returns the desired quantity for the employee benefit element being processed.&nbsp;&nbsp;</p><p><strong><br></strong></p><p><strong>Parameters:</strong></p><p>setFunctionParameter1: This parameter accepts a code for the Quantity to be returned. The possible values for this parameter are :&nbsp;</p><ul><li>Annual<br></li><li>SemiAnnual</li><li>Quarterly</li><li>Monthly</li><li>Weekly</li><li>BiWeekly</li><li>Daily</li><li>Hourly</li></ul>&nbsp;<br><p><strong><br></strong></p><p><strong>Example:</strong></p><p>[setFunctionParameter1("Annual")];</p><p>return ( [EMP_QTY]&nbsp; / 12.00 );</p>']
                , ["EMP_ELEMENT_QTY", "Quantity for a named benefit element for the employee", SPYExpressionDataType::Real, '<p>This function returns the desired quantity for a named pay element from the employee salary eligible. This function works for benefit&nbsp;type of pay elements.&nbsp;&nbsp;</p><p><br></p><p><strong>Parameters:</strong></p><p>setFunctionParameter1: This parameter accepts the code of the pay element to be fetched.&nbsp;&nbsp;</p><p>setFunctionParameter2:&nbsp;This parameter accepts a code for the qty to be returned. The possible values for this parameter are :&nbsp;</p><ul><li>Annual<br></li><li>SemiAnnual</li><li>Quarterly</li><li>Monthly</li><li>Weekly</li><li>BiWeekly</li><li>Daily</li><li>Hourly</li></ul><div><p><strong>Example:</strong></p><p>[setFunctionParameter1("Vacation")];</p><p>[setFunctionParameter2("Annual")];</p><p>return ( [EMP_ELEMENT_QTY]&nbsp; / 12.00 );</p><br></div>']
                , ["EMP_ELEMENT_AMT", "Amount for a named element for the employee", SPYExpressionDataType::Real, '<p>This function returns the desired amount for a named pay element being processed. This function works for payroll as well as benefit&nbsp;type of pay elements. The currency used for the amount returned, is the same as that entered on the salary structure of the employee. Another related function is the EMP_AMT which fetches the amount for the current pay element being processed.&nbsp;</p><p><br></p><p><strong>Parameters:</strong></p><p>setFunctionParameter1: This parameter accepts the code of the pay element to be fetched.&nbsp;&nbsp;</p><p>setFunctionParameter2: This parameter accepts a code for the amount to be returned. The possible values for this parameter are :&nbsp;</p><ul><li>Annual<br></li><li>SemiAnnual</li><li>Quarterly</li><li>Monthly</li><li>Weekly</li><li>BiWeekly</li><li>Daily</li><li>Hourly</li></ul>&nbsp;The default value for&nbsp;setFunctionParameter2 is Monthly and hence need not be specified if the monthly amount has to be fetched.&nbsp;<br><br><p><strong><br></strong></p><p><strong>Example:</strong></p><p>[setFunctionParameter1("BASIC")];<br></p><p>[setFunctionParameter2("Monthly")];</p><p>return ( [EMP_ELEMENT_AMT]&nbsp; );</p>']
            ] ;

        List    systemFunctionList = con2List(systemFunctionCon);
        ListEnumerator  systemFunctionListEnum = systemFunctionList.getEnumerator();

        delete_from expressionFunction
            where expressionFunction.SystemFunction;
        while(systemFunctionListEnum.moveNext())
        {
            container   systemFunction = systemFunctionListEnum.current();
            expressionFunction.FunctionCode = conPeek(systemFunction, 1);
            expressionFunction.Description = conPeek(systemFunction, 2);
            expressionFunction.SystemFunction = true;
            expressionFunction.DataType = conPeek(systemFunction, 3);
            expressionFunction.HelpText = conPeek(systemFunction, 4);
            expressionFunction.insert();
        }
        info("@SPY1123");
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeConfigKey</Name>
				<Source><![CDATA[
    private void initializeConfigKey()
    {
        SPYExpressionConfigurationTable     expressionConfigurationTable;
        
        if(!SPYExpressionConfigurationTable::findByKey("UnpaidLeave"))
        {
            expressionConfigurationTable.ConfigurationKey = "UnpaidLeave";
            expressionConfigurationTable.Value = '';
            expressionConfigurationTable.Notes = "Configuration key for unpaid leave code";
            expressionConfigurationTable.insert();
        }
        if(!SPYExpressionConfigurationTable::findByKey("GratuityProvision"))
        {
            expressionConfigurationTable.ConfigurationKey = "GratuityProvision";
            expressionConfigurationTable.Value = '';
            expressionConfigurationTable.Notes = "Configuration key for gratuity provision payelement code";
            expressionConfigurationTable.insert();
        }
        if(!SPYExpressionConfigurationTable::findByKey("LeaveProvision"))
        {
            expressionConfigurationTable.ConfigurationKey = "LeaveProvision";
            expressionConfigurationTable.Value = '';
            expressionConfigurationTable.Notes = "Configuration key for leave provision payelement code";
            expressionConfigurationTable.insert();
        }
        if(!SPYExpressionConfigurationTable::findByKey("BasicPayElement"))
        {
            expressionConfigurationTable.ConfigurationKey = "BasicPayElement";
            expressionConfigurationTable.Value = '';
            expressionConfigurationTable.Notes = "Configuration key for Basic pay element";
            expressionConfigurationTable.insert();
        }
        if(!SPYExpressionConfigurationTable::findByKey("VisaIdentificationType"))
        {
            expressionConfigurationTable.ConfigurationKey = "VisaIdentificationType";
            expressionConfigurationTable.Value = '';
            expressionConfigurationTable.Notes = "Configuration key for Visa identification type";
            expressionConfigurationTable.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeParameter</Name>
				<Source><![CDATA[
    private void initializeParameter()
    {
        SPYPayrollParameters        payrollParameters = SPYPayrollParameters::find(true);
        SPYPayrollParametersShared  payrollParametersShared = SPYPayrollParametersShared::find(true);
        SPYLicense  license = SPYLicense::find(true);

        if(payrollParameters)
        {
            payrollParameters.PayProcessBatchTaskSize = 100;
            payrollParameters.update();
        }
        else
        {
            payrollParameters.initValue();
            payrollParameters.PayProcessBatchTaskSize = 100;
            payrollParameters.insert();
        }

        if(payrollParametersShared)
        {
            payrollParametersShared.WebPortalMessagePageSize = 10;
            if(DocuType::find("URL"))
                payrollParametersShared.WebAttachmentDocuTypeId = "URL";
            payrollParametersShared.update();
        }
        else
        {
            payrollParametersShared.initValue();
            payrollParametersShared.WebPortalMessagePageSize = 10;
            if(DocuType::find("URL"))
                payrollParametersShared.WebAttachmentDocuTypeId = "URL";
            payrollParametersShared.insert();
        }

        SPYManaged.SPYManagedExpression     expression = new SPYManaged.SPYManagedExpression("PayProcess");
        if(license)
        {
            license.PayrollKey = expression.key();
            license.update();
        }
        else
        {
            license.PayrollKey = expression.key();
            license.insert();
        }

    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>